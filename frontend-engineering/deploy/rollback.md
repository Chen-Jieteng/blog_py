# 回滚、滚动升级、灰度部署与后端协作

## 灰度与精细流量控制

AB Test

1. 50% 的流量用于功能A。对功能 A 切分支单独开发
1. 50% 的流量用于功能B。对功能 B 切分支单独开发

那如何使仅有一半的访问到功能 A，而另一半的人访问到功能 B 呢？

我们可将项目部署为 `kubernetes`

+ 功能 A 使用一个 Deployment，部署 1 个 Pod。并暴露在服务 `cra-service-test-A`
+ 功能 B 使用一个 Deployment，部署 1 个 Pod。并暴露在服务 `cra-service-test-B`

对两个服务进行**同等权重的负载均衡**即可。

``` yaml
upstream:
  - cra-service-test-A we
  - cra-service-test-B
```

那什么是金色雀呢？而金丝雀实际上可理解为 1/10 (或者更小)的流量为新的金丝群版本(作为内测版/公测版)，而剩下流量为主版本。

> 金丝雀发布这一术语源于煤矿工人把笼养的金丝雀带入矿井的传统。矿工通过金丝雀来了解矿井中一氧化碳的浓度，如果一氧化碳的浓度过高，金丝雀就会中毒，从而使矿工知道应该立刻撤离。——《DevOps实践指南》

而无论是 AB Test、灰度部署还是金色雀，其本质上是对服务的流量控制。

## 滚动升级 (Rolling Update)

假设前端发布了 `Version 1.0` 后，并部署成功。

此时前端发布了 `Version 2.0`，如何保证流量可以平滑过度，不会因新版本无法提供服务而产生白屏等异常。

在早期一些小公司中使用 nginx 部署服务，往往先把 `Version 1.0` 版本停止服务，再对 `Version 2.0` 服务进行部署，**此时中间服务升级的过程将无法停止服务**。如果新版版有异常问题无法正常启动，则白屏时间更长。而滚动升级可以解决这个问题。

我们来看一下滚动升级的流程:

1. 使用 `Version 1` 继续提供服务
2. 对 `Version 2` 进行启动，启动后进行健康检查(Health Check)，如果健康检查通过，则开始提供服务
3. 对 `Version 2` 停止服务

> 思考题: 那此时如果一条请求到了 Version 1，而此时 Version 1 的服务刚好停止呢？

## 回滚

如何进行回滚？

那我们可以对上次版本重新部署一遍。比如在 Gitlab CI 中，我们可以通过点击升级前版本的手动部署按钮，对升级前版本进行重新部署。

但是，此时流程有点长。

